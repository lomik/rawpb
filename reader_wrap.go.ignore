package rawpb

import "io"

type Reader interface {
	io.Reader
	io.ByteScanner
}

type readerWrap struct {
	w   Reader
	mem Allocator
	buf [10]byte
}

func newReaderWrap(w Reader, mem Allocator) *readerWrap {
	return &readerWrap{
		w:   w,
		mem: mem,
	}
}

func (r *readerWrap) varint() (uint64, error) {
	var ret uint64
	var b byte
	var err error
	i := uint64(0)
	for {
		b, err = r.w.ReadByte()
		if err != nil {
			return ret, ErrorTruncated
		}
		ret += uint64(b&0x7f) << (7 * i)
		if b&0x80 == 0 { // last byte of varint
			return ret, nil
		}
		i++
	}
}

func (r *readerWrap) next() bool {
	_, err := r.w.ReadByte()
	if err != nil {
		return false
	}
	if r.w.UnreadByte() != nil {
		return false
	}
	return true
}

func (r *readerWrap) bytes(n int) ([]byte, error) {
	p := r.mem.Alloc(n)

	_, err := io.ReadAtLeast(r.w, p, n)
	if err != nil {
		return p, ErrorTruncated
	}
	return p, nil
}

func (r *readerWrap) lengthDelimited() ([]byte, error) {
	l, err := r.varint()
	if err != nil {
		return nil, err
	}
	return r.bytes(int(l))
}

func (r *readerWrap) fixed64() (uint64, error) {
	_, err := io.ReadAtLeast(r.w, r.buf[:8], 8)
	if err != nil {
		return 0, ErrorTruncated
	}

	u := uint64(r.buf[0]) | (uint64(r.buf[1]) << 8) | (uint64(r.buf[2]) << 16) | (uint64(r.buf[3]) << 24) |
		(uint64(r.buf[4]) << 32) | (uint64(r.buf[5]) << 40) | (uint64(r.buf[6]) << 48) | (uint64(r.buf[7]) << 56)
	return u, nil
}

func (r *readerWrap) fixed32() (uint32, error) {
	_, err := io.ReadAtLeast(r.w, r.buf[:4], 4)
	if err != nil {
		return 0, ErrorTruncated
	}
	u := uint32(r.buf[0]) | (uint32(r.buf[1]) << 8) | (uint32(r.buf[2]) << 16) | (uint32(r.buf[3]) << 24)
	return u, nil
}
